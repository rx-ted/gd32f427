#include "touch.h"
#include "touch_iic.h"
#include "delay.h"

#if (BSP_USING_TOUCH != 0)

/* RGB LCD模块最大触摸点数量 */
#define TOUCH_TP_MAX 5

/* RGB LCD模块触摸部分寄存器定义 */
#define TOUCH_REG_DEVIDE_MODE 0x00       /* 设备模式控制寄存器 */
#define TOUCH_REG_ID_G_MODE 0xA4         /* 中断模式控制寄存器 */
#define TOUCH_REG_ID_G_THGROUP 0x80      /* 有效触摸阈值配置寄存器 */
#define TOUCH_REG_ID_G_PERIODACTIVE 0x88 /* 激活周期配置寄存器 */
#define TOUCH_REG_TD_STATUS 0x02         /* 触摸状态寄存器 */
#define TOUCH_REG_TP1 0x03               /* 触摸点1数据寄存器 */
#define TOUCH_REG_TP2 0x09               /* 触摸点2数据寄存器 */
#define TOUCH_REG_TP3 0x0F               /* 触摸点3数据寄存器 */
#define TOUCH_REG_TP4 0x15               /* 触摸点4数据寄存器 */
#define TOUCH_REG_TP5 0x1B               /* 触摸点5数据寄存器 */

/* 触摸状态寄存器掩码 */
#define TOUCH_TD_STATUS_MASK_CNT 0x0F

/* RGB LCD模块触摸点数据寄存器 */
static const uint16_t g_touch_tp_reg[TOUCH_TP_MAX] = {
    TOUCH_REG_TP1,
    TOUCH_REG_TP2,
    TOUCH_REG_TP3,
    TOUCH_REG_TP4,
    TOUCH_REG_TP5,
};

/**
 * @brief       RGB LCD模块触摸硬件初始化
 * @param       无
 * @retval      无
 */
static void touch_hw_init(void)
{
    GPIO_InitTypeDef gpio_init_struct = {0};

    /* 使能时钟 */
    TOUCH_PEN_GPIO_CLK_ENABLE();
    TOUCH_TCS_GPIO_CLK_ENABLE();

    /* 初始化PEN引脚 */
    gpio_init_struct.Pin = TOUCH_PEN_GPIO_PIN;
    gpio_init_struct.Mode = GPIO_MODE_INPUT;
    gpio_init_struct.Pull = GPIO_PULLUP;
    gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(TOUCH_PEN_GPIO_PORT, &gpio_init_struct);

    /* 初始化TCS引脚 */
    gpio_init_struct.Pin = TOUCH_TCS_GPIO_PIN;
    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_PP;
    gpio_init_struct.Pull = GPIO_PULLUP;
    gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(TOUCH_TCS_GPIO_PORT, &gpio_init_struct);
}

/**
 * @brief       RGB LCD模块触摸硬件复位
 * @param       无
 * @retval      无
 */
static void touch_hw_reset(void)
{
    TOUCH_TCS(0);
    delay_ms(20);
    TOUCH_TCS(1);
    delay_ms(50);
}

/**
 * @brief       写RGB LCD模块触摸寄存器
 * @param       reg: 待写寄存器地址
 *              buf: 待写入的数据
 *              len: 待写入数据的长度
 * @retval      TOUCH_EOK  : 写ATK-RGBLCD模块触摸寄存器成功
 *              TOUCH_ERROR: 写ATK-RGBLCD模块触摸寄存器失败
 */
static uint8_t touch_write_reg(uint16_t reg, uint8_t *buf, uint8_t len)
{
    uint8_t buf_index;
    uint8_t ret;

    touch_iic_start();
    touch_iic_send_byte((TOUCH_IIC_ADDR_38 << 1) | TOUCH_IIC_WRITE);
    touch_iic_wait_ack();
    touch_iic_send_byte(reg);
    touch_iic_wait_ack();

    for (buf_index = 0; buf_index < len; buf_index++)
    {
        touch_iic_send_byte(buf[buf_index]);
        ret = touch_iic_wait_ack();
        if (ret != 0)
        {
            break;
        }
    }

    touch_iic_stop();

    if (ret != 0)
    {
        return TOUCH_ERROR;
    }

    return TOUCH_EOK;
}

/**
 * @brief       读RGB LCD模块触摸寄存器
 * @param       reg: 待读寄存器地址
 *              buf: 读取的数据
 *              len: 待读取数据的长度
 * @retval      无
 */
void touch_iic_read_reg(uint8_t reg, uint8_t *buf, uint8_t len)
{
    uint8_t buf_index;

    touch_iic_start();
    touch_iic_send_byte((TOUCH_IIC_ADDR_38 << 1) | TOUCH_IIC_WRITE);
    touch_iic_wait_ack();
    touch_iic_send_byte(reg);
    touch_iic_wait_ack();
    touch_iic_start();
    touch_iic_send_byte((TOUCH_IIC_ADDR_38 << 1) | TOUCH_IIC_READ);
    touch_iic_wait_ack();

    for (buf_index = 0; buf_index < len - 1; buf_index++)
    {
        buf[buf_index] = touch_iic_recv_byte(1);
    }

    buf[buf_index] = touch_iic_recv_byte(0);

    touch_iic_stop();
}

/**
 * @brief       RGB LCD模块触摸寄存器初始化
 * @param       无
 * @retval      无
 */
static void touch_reg_init(void)
{
    uint8_t dat;

    /* 设备模式控制寄存器 */
    dat = 0x00;
    touch_write_reg(TOUCH_REG_DEVIDE_MODE, &dat, sizeof(dat));

    /* 中断模式控制寄存器 */
    dat = 0x00;
    touch_write_reg(TOUCH_REG_ID_G_MODE, &dat, sizeof(dat));

    /* 有效触摸阈值配置寄存器 */
    dat = 22;
    touch_write_reg(TOUCH_REG_ID_G_THGROUP, &dat, sizeof(dat));

    /* 激活周期配置寄存器，不能小于12 */
    dat = 12;
    touch_write_reg(TOUCH_REG_ID_G_PERIODACTIVE, &dat, sizeof(dat));
}

/**
 * @brief       RGB LCD模块触摸初始化
 * @param       无
 * @retval      TOUCH_EOK  : RGB LCD模块触摸初始化成功
 *              TOUCH_ERROR: RGB LCD模块触摸初始化失败
 */
uint8_t touch_init(touch_type_t type)
{
    if (type != TOUCH_TYPE_FTXX)
    {
        return TOUCH_ERROR;
    }

    touch_hw_init();
    touch_hw_reset();
    touch_iic_init();
    touch_reg_init();

    return TOUCH_EOK;
}

/**
 * @brief       RGB LCD模块触摸扫描
 * @note        连续调用间隔需大于4ms
 * @param       point: 扫描到的触摸点信息
 *              cnt  : 需要扫描的触摸点数量（1~TOUCH_TP_MAX）
 * @retval      0   : 没有扫描到触摸点
 *              其他: 实际获取到的触摸点信息数量
 */
uint8_t touch_scan(touch_point_t *point, uint8_t cnt)
{
    uint8_t tp_stat;
    uint8_t tp_cnt;
    uint8_t point_index;
    lcd_disp_dir_t dir;
    uint8_t tpn_info[4];
    touch_point_t point_raw;

    if ((cnt == 0) || (cnt > TOUCH_TP_MAX))
    {
        return 0;
    }

    for (point_index = 0; point_index < cnt; point_index++)
    {
        if (&point[point_index] == NULL)
        {
            return 0;
        }
    }

    touch_iic_read_reg(TOUCH_REG_TD_STATUS, &tp_stat, sizeof(tp_stat));
    tp_cnt = tp_stat & TOUCH_TD_STATUS_MASK_CNT;
    if ((tp_cnt != 0) && (tp_cnt <= TOUCH_TP_MAX))
    {
        tp_cnt = (cnt < tp_cnt) ? cnt : tp_cnt;

        for (point_index = 0; point_index < tp_cnt; point_index++)
        {
            touch_iic_read_reg(g_touch_tp_reg[point_index], tpn_info, sizeof(tpn_info));
            point_raw.x = (uint16_t)((tpn_info[0] & 0x0F) << 8) | tpn_info[1];
            point_raw.y = (uint16_t)((tpn_info[2] & 0x0F) << 8) | tpn_info[3];

            dir = get_disp_dir();
            switch (dir)
            {
            case LCD_DISP_DIR_0:
            {
                point[point_index].x = point_raw.y;
                point[point_index].y = point_raw.x;
                break;
            }
            case LCD_DISP_DIR_90:
            {
                point[point_index].x = point_raw.x;
                point[point_index].y = get_lcd_height() - point_raw.y;
                break;
            }
            case LCD_DISP_DIR_180:
            {
                point[point_index].x = get_lcd_width() - point_raw.y;
                point[point_index].y = get_lcd_height() - point_raw.x;
                break;
            }
            case LCD_DISP_DIR_270:
            {
                point[point_index].x = get_lcd_width() - point_raw.x;
                point[point_index].y = point_raw.y;
                break;
            }
            }
        }

        return tp_cnt;
    }
    else
    {
        return 0;
    }
}

#endif
